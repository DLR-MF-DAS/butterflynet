"""
This code is generated by Ridvan Salih KUZU @DLR
LAST EDITED:  01.06.2021
ABOUT SCRIPT:
It contains some custom image postprocessing techniques for experimental purposes in this project.
"""

import numpy as np
from skimage import io
from PIL import Image
from skimage.draw import polygon2mask
from scipy import ndimage
from scipy.signal import medfilt2d #,wiener
#from scipy.ndimage import gaussian_filter
from skimage import measure


def threshold_mask(pred_mask, th = 0.5):
    '''
    THIS FUNCTION THRESHOLD THE MASK VALUES TO BINARY VALUES.
    :param pred_mask: predicted mask by the UNET architecture
    :param th: threshold value for binary representation
    :return: returns the binarized mask image
    '''
    pred_mask[pred_mask >= th] = 1
    pred_mask[pred_mask < th ]=0

    return pred_mask


def _binary_opening_closing(binary_img):
    '''
    THIS FUNCTION MAKES BINARY IMAGE OPENING AND CLOSING IN ORDER.
    :param binary_img: binary image data
    :return: returns post-procesed image
    '''
    binary_img = ndimage.morphology.binary_fill_holes(binary_img)
    binary_img = ndimage.binary_erosion(binary_img)
    binary_img=ndimage.binary_propagation(binary_img, mask=binary_img)
    #binary_img = ndimage.binary_opening(binary_img)
    #binary_img = ndimage.binary_closing(binary_img)

    return binary_img

def _contour_finding(mask, threshold):
    '''
    THIS FUNCTION FINDS THE CONTOURS IN A GIVEN IMAGE.
    :param mask: mask image to be processed for contour finding
    :param threshold: minimum pixel diameter for the considered contours
    :return: returns contour boundary pixels, and contour mask
    '''
    clone_mask=mask.copy()
    clone_mask[0, :] = clone_mask[:, 0] = clone_mask[:, -1] = clone_mask[-1, :] = 0
    contours = measure.find_contours(clone_mask, 0.8)
    c_mask = np.zeros_like(clone_mask, dtype='bool')
    c_boundary = np.zeros_like(clone_mask, dtype='bool')
    for contour in contours:
        if contour.size > threshold:
            c_mask=np.logical_or(c_mask,polygon2mask(clone_mask.shape, contour))
            c_boundary[np.round(contour[:, 0]).astype('int'), np.round(contour[:, 1]).astype('int')] = 1

    return c_boundary, c_mask

def _overlap_images(image, c_mask):
    '''
    THIS FUNCTION MAKES RASTER OF INPUT IMAGE AND CONTOUR MASK IN A SINGLE IMAGE.
    :param image: input image
    :param c_mask: contour pixels of the mask image
    :return: returns raster (overlapped) image
    '''
    nc_mask = ~c_mask
    gb_out = image * nc_mask
    c_mask = c_mask * 1
    c_mask[c_mask == 0] = -255
    c_mask[c_mask == 1] = 255
    r_out = np.maximum(image, c_mask)

    RGB = np.zeros((nc_mask.shape[0], nc_mask.shape[1], 3), 'uint8')
    RGB[:, :, 0] = r_out
    RGB[:, :, 1] = gb_out
    RGB[:, :, 2] = gb_out
    return RGB


def post_processing(in_image_file, in_mask_file, out_overlap_file, out_mask_file,out_contour_file, contour_threshold, smoother):
    '''
    THIS FUNCTION MAKES ALL THE POSTPROCESSING STEPS AND SAVES THEM ACCORDINGLY.
    :param in_image_file: path to the input image file
    :param in_mask_file: path to the input mask file (ground-truth or predicted input mask)
    :param out_overlap_file: path to the generated overlap file  (RASTER OF INPUT IMAGE AND CONTOUR MASK)
    :param out_mask_file: path to the post-processed mask file (output mask)
    :param contour_threshold: minimum pixel diameter for the considered contours
    :param smoother: kernel size for image smoothing
    :return: returns nothing
    '''

    image = io.imread(in_image_file)
    mask = io.imread(in_mask_file)

    if smoother>1:
        kernel = smoother * 2 + 1
        mask = medfilt2d(mask.astype(np.uint8), (kernel,kernel))
        mask = _binary_opening_closing(mask)

    #c_mask=gaussian_filter(mask.astype(np.uint8),smoother)
    c_boundary, c_mask = _contour_finding(mask, contour_threshold)

    out_overlap_image = _overlap_images(image, c_boundary)
    out_overlap_image=Image.fromarray(out_overlap_image.astype(np.uint8))
    out_overlap_image.save(out_overlap_file)

    temp_image=np.zeros(image.shape, 'uint8')
    out_contour_image = _overlap_images(temp_image, c_boundary)
    out_contour_image = Image.fromarray(out_contour_image.astype(np.uint8))
    out_contour_image.save(out_contour_file)

    #c_mask = ndimage.morphology.binary_fill_holes(c_mask)
    if contour_threshold == 0:
        c_mask = mask
    else:
        c_mask=255*c_mask.astype(np.uint8)

    out_mask_image = Image.fromarray(c_mask)
    out_mask_image.save(out_mask_file)